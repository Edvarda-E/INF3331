import os
import argparse
import re
from filereader import read_syntax_file, read_color_file


def color_injection(output_string, reg_col_dict, group=0):
    """
    Matches and injects color to the output based on the dictionary given

    Arguments:
        output_string (str):   String to be matched and colored
        reg_col_dict (dict):   A combined dictionary in the format RegEx: bash color sequence
        group (int, optional): What group to choose from the matches

    Returns:
        output_string (str): A fully colored string
    """
    # Makes a list containing and storing the start of the match, the end of the match and the
    # color code that belongs to the match
    store_match_to_colors = []
    color_offset = 0  # Keeping track of the offset caused by adding the bash color seqs in the text
    previous_match_end = -1  # Last index of the previous match

    # Build up a dictionary of matches and colors
    for regex, color in reg_col_dict.items():
        for match in re.finditer(regex, output_string, flags=re.MULTILINE):
            store_match_to_colors.append((match.start(group), match.end(group), color))
    store_match_to_colors.sort(key=lambda match_and_color: match_and_color[0])

    # Builds up the matched string with colors
    for start_index, end_index, color in store_match_to_colors:
        # Prevents the new match to overlap with the previous match
        if start_index + color_offset >= previous_match_end:
            match_string = \
                f'\033[{color}m{output_string[(start_index + color_offset) : (end_index + color_offset)]}\033[0m'
            output_string = output_string[:(start_index + color_offset)] + \
                            match_string + output_string[(end_index + color_offset):]
            color_offset += len(match_string) - (end_index-start_index)
            previous_match_end = end_index + color_offset

    return output_string


def highlight(input_file, regex_dict, theme_dict):
    """
    Highlights an input file based of the regex- and theme color dictionary supplied

    Arguments:
        input_file (str):   A file with content to be matched by the regexes
        regex_dict (dict):  Regex dictionary in the format "RegEx": name
        theme_dict (dict):  Theme with bash color sequences in the format name: bash_color_seq
    Returns:
        Colored text (str): Generated by color_injection
    """
    combined_dict = {reg.strip('\"'): theme_dict[key] for reg, key in regex_dict.items()}
    return color_injection(input_file, combined_dict, group=1)


# def color_injection(match, color):
#     print("---------")
#     print(match, color)
#     return "Hello"
#
#
# def highlight(input, regex_dict, theme_dict=None):
#     """
#
#     :param input:
#     :param regex_dict:
#     :param theme_dict:
#     :return:
#     """
#     end_color = r'\033[0m'
#     match_string_array = [None] * len(input)
#     print("::::::::")
#     for regex, regex_name in regex_dict.items():
#         # matcher = re.compile(regex.strip('\"'))  # Remove the " from the RegEx strings
#         for color_name, color_theme in theme_dict.items():
#             if regex_name in theme_dict and color_name == regex_name:
#                 re.sub(r'{}'.format(regex.strip('\"')), lambda match, color=color_theme: color_injection(match, color), input, flags=re.MULTILINE)


def main():
    """
    Parses positional arguments and highlights an input file based on the given RegEx and theme colors given
    from the terminal

    Arguments:
        syntax file (file): A .syntax file as a RegEx dictionary
        theme file (file:   A .theme file as a bash color sequence dictionary
        output file (file): An arbitrary file with contents to be outputted to the terminal

    Returns:
        Calls the highlight function that prints the matched output to the terminal
    """
    parser = argparse.ArgumentParser(description="Highlight parts of an output file in the terminal using a syntax "
                                                 "dictionary, a theme dictionary and a file to apply them to")
    parser.add_argument("syntax",
                        type=str,
                        help="A syntax file, containing a dictionary of RegExes and associated names\n"
                             "Example: NNNN.*(?:$|): comment")
    parser.add_argument("theme",
                        type=str,
                        help="A theme file, containing a dictionary of associated names and color following the "
                             "bash color sequence\n"
                             "Example: comment: 0;32")
    parser.add_argument("output_file",
                        type=str,
                        help="A file where the RegEx syntax and the theme colors will be applied")
    args = parser.parse_args()

    # Verifies that all parameters are actually files
    if os.path.isfile(args.syntax) and os.path.isfile(args.theme) and os.path.isfile(args.output_file):
        regex_dict = read_syntax_file(args.syntax)
        color_dict = read_color_file(args.theme)
        with open(args.output_file, 'r') as file:
            output_string = file.read()
            colored_text = highlight(output_string, regex_dict, color_dict)
        print(colored_text)

    else:
        print("\nError: highlighter.py expects to receive three files as arguments as follows:\n"
              ">>> highlighter.py foo.syntax bar.theme baz.any")


# Called if the highlighter.py script is called directly
if __name__ == '__main__':
    main()
